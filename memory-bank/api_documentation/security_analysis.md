# Remodl Core API Security Patterns

This document outlines the observed API authentication and authorization mechanisms within the Remodl Core server.

## 1. Primary Authentication: API Key (Bearer Token)

-   **Mechanism:** Most internal API endpoints are protected and expect an API key to be provided in the `Authorization` header as a Bearer token.
    -   Format: `Authorization: Bearer <API_KEY_VALUE>`
    -   The `<API_KEY_VALUE>` is the plaintext API key generated by the system (typically starting with `flow_...`).
-   **Key Generation & Storage (`apikey` module):
    *   When a new API key is created (e.g., via `POST /api/v1/apikey/`):
        *   A plaintext `apiKey` (e.g., `flow_...`) is generated.
        *   A unique `apiSecret` is generated by creating a salted hash of this plaintext `apiKey` (using `scryptSync`). The format stored is `hashedKey.salt`.
        *   Both the plaintext `apiKey` and the salted/hashed `apiSecret` are stored (either in a JSON file or a database, depending on `APIKEY_STORAGE_TYPE` environment variable).
    *   The plaintext API key value is returned to the user only upon creation.
-   **Validation (`utils/validateKey.ts` - `validateAPIKey` function):
    *   The middleware (presumed global) extracts the `suppliedKey` from the `Authorization: Bearer` header.
    *   It attempts to find a stored API key record where the stored *plaintext* `apiKey` field matches the `suppliedKey`.
    *   If a match is found, it retrieves the associated stored `apiSecret` (the `hashedKey.salt` string).
    *   It then uses `compareKeys(storedApiSecret, suppliedKey)`. The `compareKeys` function:
        *   Extracts the `salt` from the `storedApiSecret`.
        *   Re-hashes the `suppliedKey` (the plaintext `flow_...` key) using this `salt` and `scryptSync`.
        *   Performs a timing-safe comparison between this newly generated hash and the hash part of the `storedApiSecret`.
    *   Access is granted if the comparison is successful.

## 2. Chatflow-Specific API Key Restriction

-   **Mechanism (`utils/validateKey.ts` - `validateChatflowAPIKey` function):
    *   Individual chatflows can be associated with a specific API key ID via the `chatflow.apikeyid` field.
    *   Endpoints that operate on a specific chatflow (e.g., `POST /predictions/{id}`) use `validateChatflowAPIKey`.
    *   If `chatflow.apikeyid` is set, this validation works identically to the general `validateAPIKey` but specifically uses the API key record identified by `chatflow.apikeyid` for comparison against the `Authorization` header.
    *   If `chatflow.apikeyid` is *not* set for a particular chatflow, `validateChatflowAPIKey` returns `true`, meaning that chatflow does not require its own specific API key for access (though a global API key might still be enforced by middleware).

## 3. Unauthenticated / Public Endpoints

-   Certain endpoints are designed for public access or have their own verification logic and do not typically require the standard `Authorization` header with a Remodl Core API key. Examples include:
    *   `GET /api/v1/public-chatbots/{id}`
    *   `GET /api/v1/public-chatflows/{id}`
    *   `GET /api/v1/verify/apikey/{apikey}` (This endpoint verifies a key, so it's unauthenticated itself).
    *   `GET /api/v1/ping/` (Standard health check).

## 4. Credential Usage by Services

-   Many services that interact with third-party APIs (e.g., `openai-assistants`, `services/llms/`) require credentials (like an OpenAI API key).
-   These are typically passed into service methods as a `credentialId` (a UUID referring to a record in the Remodl Core `Credential` entity).
-   The service then retrieves the `Credential` record, decrypts its `encryptedData` to get the actual third-party API key, and uses that for the external API call.
-   This is distinct from the Remodl Core API key authentication used to protect the Remodl Core endpoints themselves.

## Implications for OpenAPI Documentation:

-   A global `securityScheme` named (e.g.) `RemodlCoreApiKeyAuth` of type `http` and scheme `bearer` should be defined.
-   Most internal API endpoints should reference this global security scheme in their `security` field.
-   Publicly accessible endpoints should have their `security` field explicitly omitted or set to `[]`.
-   Descriptions for endpoints that use `credentialId` query or body parameters should clarify that these refer to stored Remodl Core credentials for third-party services.
